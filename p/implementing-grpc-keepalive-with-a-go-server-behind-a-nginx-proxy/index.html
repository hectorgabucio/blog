<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="A practical guide to implementing reliable connection health checks for gRPC server streams when working with Nginx proxy, including a custom keepalive solution and real-world considerations"><title>Implementing gRPC Keepalive with a Go server behind a nginx proxy</title>
<link rel=canonical href=https://blog.hectorgabucio.com/p/implementing-grpc-keepalive-with-a-go-server-behind-a-nginx-proxy/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Implementing gRPC Keepalive with a Go server behind a nginx proxy"><meta property='og:description' content="A practical guide to implementing reliable connection health checks for gRPC server streams when working with Nginx proxy, including a custom keepalive solution and real-world considerations"><meta property='og:url' content='https://blog.hectorgabucio.com/p/implementing-grpc-keepalive-with-a-go-server-behind-a-nginx-proxy/'><meta property='og:site_name' content="Héctor's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='grpc'><meta property='article:tag' content='go'><meta property='article:tag' content='nginx'><meta property='article:tag' content='networking'><meta property='article:tag' content='backend'><meta property='article:tag' content='http2'><meta property='article:tag' content='keepalive'><meta property='article:published_time' content='2025-05-09T00:00:00+00:00'><meta property='article:modified_time' content='2025-05-09T00:00:00+00:00'><meta name=twitter:title content="Implementing gRPC Keepalive with a Go server behind a nginx proxy"><meta name=twitter:description content="A practical guide to implementing reliable connection health checks for gRPC server streams when working with Nginx proxy, including a custom keepalive solution and real-world considerations"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar2_hu_78044ca83c41f268.png width=300 height=166 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Héctor's Blog</a></h1><h2 class=site-description>Get ready for some no-nonsense backend engineering talk.</h2></div></header><ol class=menu-social><li><a href=https://github.com/hectorgabucio target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/hectorjosecompangabucio target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-linkedin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></a></li><li><a href=https://hectorgabucio.com target=_blank title="Personal website" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-world-www"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19.5 7A9 9 0 0012 3 8.991 8.991.0 004.516 7"/><path d="M11.5 3A16.989 16.989.0 009.674 7"/><path d="M12.5 3a16.989 16.989.0 011.828 4"/><path d="M19.5 17A9 9 0 0112 21a8.991 8.991.0 01-7.484-4"/><path d="M11.5 21a16.989 16.989.0 01-1.826-4"/><path d="M12.5 21a16.989 16.989.0 001.828-4"/><path d="M2 10l1 4 1.5-4L6 14l1-4"/><path d="M17 10l1 4 1.5-4 1.5 4 1-4"/><path d="M9.5 10l1 4 1.5-4 1.5 4 1-4"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#intro>Intro</a></li><li><a href=#the-challenge>The Challenge</a></li><li><a href=#understanding-grpc-keepalive>Understanding gRPC Keepalive</a></li><li><a href=#hands-on-with-grpc-keepalive>Hands-on with gRPC Keepalive</a><ol><li><a href=#testing-connection-loss>Testing Connection Loss</a></li><li><a href=#the-nginx-surprise>The Nginx Surprise</a></li><li><a href=#reproducing-the-issue>Reproducing the Issue</a><ol><li><a href=#first-weird-behavior-missing-client-pings>First Weird Behavior: Missing Client Pings</a></li><li><a href=#the-mystery-deepens>The Mystery Deepens</a></li></ol></li><li><a href=#the-investigation>The Investigation</a></li><li><a href=#the-nginx-teams-response>The NGINX Team&rsquo;s Response</a></li><li><a href=#the-tcp-keepalive-alternative>The TCP Keepalive Alternative</a></li></ol></li><li><a href=#the-problem>The Problem</a></li><li><a href=#the-failed-partial-workaround>The Failed Partial Workaround</a><ol><li><a href=#the-server-side-ping-attempt>The Server-Side Ping Attempt</a></li><li><a href=#the-nginx-buffering-discovery>The Nginx Buffering Discovery</a></li></ol></li><li><a href=#the-successful-workaround>The Successful Workaround</a></li><li><a href=#implementation-details>Implementation Details</a><ol><li><a href=#ping-frequency>Ping Frequency</a></li><li><a href=#security-considerations>Security Considerations</a></li></ol></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#thoughts>Thoughts</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/backend/>Backend
</a><a href=/categories/networking/>Networking</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/implementing-grpc-keepalive-with-a-go-server-behind-a-nginx-proxy/>Implementing gRPC Keepalive with a Go server behind a nginx proxy</a></h2><h3 class=article-subtitle>A practical guide to implementing reliable connection health checks for gRPC server streams when working with Nginx proxy, including a custom keepalive solution and real-world considerations</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>May 09, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>13 minute read</time></div></footer></div></header><section class=article-content><h2 id=intro>Intro</h2><p>Grab a coffee and join me on this journey through the challenges of implementing gRPC keepalive in a Go service behind an Nginx proxy. I&rsquo;ll share my experience, the problems I encountered, and how I found a solution that actually works in production.</p><h2 id=the-challenge>The Challenge</h2><p>In a recent project, I faced an interesting challenge: implementing a gRPC server stream that needed to maintain a healthy connection. This was particularly important because our client was a mobile application that could experience poor signal quality, intermittent data loss, and other connectivity issues. The natural approach would be to use gRPC&rsquo;s built-in keepalive mechanism, but there was a catch - we were using Nginx as a proxy.</p><h2 id=understanding-grpc-keepalive>Understanding gRPC Keepalive</h2><p>Before diving into the problem, let&rsquo;s understand how gRPC keepalive works. The official documentation can be found in the <a class=link href=https://grpc.io/docs/guides/keepalive/ target=_blank rel=noopener>gRPC keepalive guide</a>.</p><p>TCP keepalive is a well-known method of maintaining connections and detecting broken connections. When TCP keepalive is enabled, either side of the connection can send redundant packets. Once ACKed by the other side, the connection will be considered as good. If no ACK is received after repeated attempts, the connection is deemed broken.</p><p>Unlike TCP keepalive, gRPC uses HTTP/2 which provides a mandatory PING frame (specified in <a class=link href=https://httpwg.org/specs/rfc7540.html#PING target=_blank rel=noopener>RFC 7540</a>) that can be used to:</p><ul><li>Estimate round-trip time</li><li>Measure bandwidth-delay product</li><li>Test the connection health</li></ul><p>The interval and retry mechanisms in TCP keepalive don&rsquo;t quite apply to HTTP/2 PING frames because the transport is reliable. Instead, they&rsquo;re replaced with a timeout value (equivalent to interval * retry) in gRPC&rsquo;s PING-based keepalive implementation.</p><h2 id=hands-on-with-grpc-keepalive>Hands-on with gRPC Keepalive</h2><p>Let&rsquo;s explore how gRPC keepalive works in practice using a simple example. First, we&rsquo;ll enable keepalive on the client side:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>val</span> <span class=py>channel</span> <span class=p>=</span> <span class=n>ManagedChannelBuilder</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>forAddress</span><span class=p>(</span><span class=n>SERVER_IP</span><span class=p>,</span> <span class=n>SERVER_PORT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>usePlaintext</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Send ping frames every 10 seconds
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>keepAliveTime</span><span class=p>(</span><span class=m>10</span><span class=p>,</span> <span class=nc>TimeUnit</span><span class=p>.</span><span class=n>SECONDS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Server should respond to ping in 15 seconds max
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>keepAliveTimeout</span><span class=p>(</span><span class=m>15</span><span class=p>,</span> <span class=nc>TimeUnit</span><span class=p>.</span><span class=n>SECONDS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>To see the HTTP/2 frames in action, we can run our server with debug logging enabled:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>env <span class=nv>GODEBUG</span><span class=o>=</span><span class=nv>http2debug</span><span class=o>=</span><span class=m>2</span> go run main.go
</span></span></code></pre></td></tr></table></div></div><p>When we connect our client and start the stream, we&rsquo;ll see the following in the logs:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>2025/05/09 19:06:53 http2: Framer 0x1400018a540: <span class=nb>read</span> PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xa1\x97GVkb\xb4|&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:06:53 http2: Framer 0x1400018a540: wrote PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xa1\x97GVkb\xb4|&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:03 http2: Framer 0x1400018a540: <span class=nb>read</span> PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xd9L\xad&gt;&amp;\b\xb8\x86&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:03 http2: Framer 0x1400018a540: wrote PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xd9L\xad&gt;&amp;\b\xb8\x86&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:13 http2: Framer 0x1400018a540: <span class=nb>read</span> PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xd84|3G6|\x1a&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:13 http2: Framer 0x1400018a540: wrote PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xd84|3G6|\x1a&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:23 http2: Framer 0x1400018a540: <span class=nb>read</span> PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xd4\xdeڬ\x858\x89\x82&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:23 http2: Framer 0x1400018a540: wrote PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xd4\xdeڬ\x858\x89\x82&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:23 http2: Framer 0x1400018a540: wrote GOAWAY <span class=nv>len</span><span class=o>=</span><span class=m>22</span> <span class=nv>LastStreamID</span><span class=o>=</span><span class=m>3</span> <span class=nv>ErrCode</span><span class=o>=</span>ENHANCE_YOUR_CALM <span class=nv>Debug</span><span class=o>=</span><span class=s2>&#34;too_many_pings&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:07:24 Context cancelled
</span></span><span class=line><span class=cl>2025/05/09 19:07:24 Stream ended
</span></span></code></pre></td></tr></table></div></div><p>As we can see, the client is sending ping frames every 10 seconds (note: this is the minimum allowed for the Java client). Even though we haven&rsquo;t enabled keepalive on our server, it&rsquo;s responding with PING frames with the ACK flag. However, after a few pings, it sends a GOAWAY frame with the code <code>ENHANCE_YOUR_CALM</code>. This happens because the server isn&rsquo;t configured to accept ping frames, so it terminates the connection.</p><p>Let&rsquo;s enable keepalive on the server side as well:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>grpc</span><span class=p>.</span><span class=nf>KeepaliveParams</span><span class=p>(</span><span class=nx>keepalive</span><span class=p>.</span><span class=nx>ServerParameters</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Time</span><span class=p>:</span>    <span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Timeout</span><span class=p>:</span> <span class=mi>15</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}))</span>
</span></span></code></pre></td></tr></table></div></div><p>Now the logs show bidirectional ping communication:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>2025/05/09 19:24:30 http2: Framer 0x14000200540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:24:30 http2: Framer 0x14000200540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:24:40 http2: Framer 0x14000200540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:24:40 http2: Framer 0x14000200540: <span class=nb>read</span> PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xa6\x9c#UD[\x83\xd0&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:24:40 http2: Framer 0x14000200540: wrote PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\xa6\x9c#UD[\x83\xd0&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:24:40 http2: Framer 0x14000200540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>We can see both &ldquo;wrote PING&rdquo;, &ldquo;wrote PING ACK&rdquo;, &ldquo;read PING&rdquo;, and &ldquo;read PING ACK&rdquo; messages, indicating that both sides are actively sending pings to each other. This is exactly what we want!</p><h3 id=testing-connection-loss>Testing Connection Loss</h3><p>Let&rsquo;s see what happens when the Android app loses connection. We can simulate this by enabling airplane mode:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>2025/05/09 19:28:07 Received request: Hello Server!
</span></span><span class=line><span class=cl>2025/05/09 19:28:07 http2: Framer 0x14000200540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x02\x04\x10\x10\t\x0e\a\a&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:28:07 http2: Framer 0x14000200540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x02\x04\x10\x10\t\x0e\a\a&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>(</span>at this point, I enabled airplane mode in the android emulator<span class=o>)</span>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>2025/05/09 19:28:17 http2: Framer 0x14000200540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>2025/05/09 19:28:32 Context cancelled
</span></span><span class=line><span class=cl>2025/05/09 19:28:32 Stream ended
</span></span></code></pre></td></tr></table></div></div><p>The server sends a PING frame at 19:28:17 to check the connection. After 15 seconds (our configured keepalive timeout) with no response, the server terminates the connection. This is exactly the behavior we want!</p><h3 id=the-nginx-surprise>The Nginx Surprise</h3><p>After successfully testing locally, I deployed the solution to our test environment. We use Ingress Nginx as our reverse proxy for backend services, which provides load balancing, security, rate limiting, and other features. However, when testing the keepalive mechanism in this environment, something unexpected happened.</p><p>Even with airplane mode enabled on the phone, <strong>the server was still receiving ACK responses to its PING frames. This was confusing because we knew the client was disconnected, but the server thought the connection was still alive.</strong></p><p align=center><img alt="WTF meme" src=https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExZHY4OHlsZTR4Z3BpeWltaThtenN1NHYzb2kxb2hocDZ3aG5vMm43cSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/b8RQzkElbBsXqEPF2X/giphy.gif></p><h3 id=reproducing-the-issue>Reproducing the Issue</h3><p>To better understand the problem, I used my toy project to reproduce the issue. I added an nginx proxy between the Android client and the server by running a Docker container with nginx, configured to forward traffic to my Go service.</p><p>Let&rsquo;s start by running our Docker Compose setup:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose up --build
</span></span></code></pre></td></tr></table></div></div><h4 id=first-weird-behavior-missing-client-pings>First Weird Behavior: Missing Client Pings</h4><p>We immediately notice something strange - the server isn&rsquo;t receiving the client&rsquo;s ping frames:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:51:17 Received request: Hello Server!
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:51:27 http2: Framer 0x40000e4540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:51:27 http2: Framer 0x40000e4540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:51:37 http2: Framer 0x40000e4540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:51:37 http2: Framer 0x40000e4540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice how we only see PINGs that the server is writing, and someone is sending ACKs. But who?</p><h4 id=the-mystery-deepens>The Mystery Deepens</h4><p>Let&rsquo;s try enabling airplane mode on the phone. Surely we shouldn&rsquo;t see any PING ACKs now, right?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:53:50 Received request: Hello Server!
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>(</span>I enabled airplane mode here<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:54:00 http2: Framer 0x40000e4540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:54:00 http2: Framer 0x40000e4540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:54:10 http2: Framer 0x40000e4540: wrote PING <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span><span class=line><span class=cl>grpc-server-1  <span class=p>|</span> 2025/05/09 17:54:10 http2: Framer 0x40000e4540: <span class=nb>read</span> PING <span class=nv>flags</span><span class=o>=</span>ACK <span class=nv>len</span><span class=o>=</span><span class=m>8</span> <span class=nv>ping</span><span class=o>=</span><span class=s2>&#34;\x00\x00\x00\x00\x00\x00\x00\x00&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p align=center><img alt="Mystery meme" src=https://media1.tenor.com/m/0UBIdauP8CoAAAAC/iker-jimenez-misterioso.gif></p><p>Who is responding to the pings when the client has airplane mode enabled?</p><h3 id=the-investigation>The Investigation</h3><p>After some research, I found a <a class=link href=https://github.com/kubernetes/ingress-nginx/issues/4402 target=_blank rel=noopener>GitHub issue</a> where someone reported the same problem:</p><blockquote><p>&ldquo;Currently my grpc server is doing keep alive ping each 10 seconds and ngnix proxy is doing ack of the ping but ngnix itself is not pinging client.&rdquo;</p></blockquote><p>However, there wasn&rsquo;t a clear solution in that issue. Then I discovered an even older issue in the nginx issue tracker, <a class=link href=https://trac.nginx.org/nginx/ticket/1887 target=_blank rel=noopener>closed as &ldquo;WONT FIX&rdquo; from 5 years ago</a>.</p><p>The issue description was particularly relevant:</p><blockquote><p>&ldquo;gRPC has multiple options for keepalive, which are especially relevant for streaming messages:</p><p><a class=link href=https://github.com/grpc/grpc/blob/master/doc/keepalive.md target=_blank rel=noopener>https://github.com/grpc/grpc/blob/master/doc/keepalive.md</a></p><p>With these you are able to track disappearing clients and narrow connection latency. gRPC uses HTTP/2 ping messages for keepalives. When proxying through nginx, nginx does not passthrough ping messages to the client.</p><p>When using nginx with gRPC you currently have to implement a form of keepalive yourself. Send and receive timeouts from nginx are not helpful, as we use gRPC with long-lived streaming connections.</p><p>Possible solutions:</p><ol><li>Add an option to passthrough HTTP/2 ping messages to the gRPC backend: <code>grpc_ping_passthrough yes/no</code>.</li><li>Add ability to send keepalive pings from nginx. In this case nginx would need additional options and nginx would have to terminate the connection if there is no response to the ping messages, similar to what gRPC does.&rdquo;</li></ol></blockquote><h3 id=the-nginx-teams-response>The NGINX Team&rsquo;s Response</h3><p>The NGINX team&rsquo;s response was clear. They explained that using HTTP/2 pings to check client connectivity doesn&rsquo;t work well with NGINX as a proxy because:</p><ol><li>A single connection to the backend may serve multiple clients (especially with HTTP/2 multiplexing)</li><li>There&rsquo;s no persistent connection between the client and the backend unless there&rsquo;s an active request</li><li>Multiple simultaneous client requests mean multiple client-server connections</li></ol><p>Their conclusion was straightforward: HTTP/2 pings only help verify direct (peer-to-peer) connections, not end-to-end connectivity through a proxy.</p><h3 id=the-tcp-keepalive-alternative>The TCP Keepalive Alternative</h3><p>As a possible solution, they mentioned using TCP keepalive. However, I rejected this idea because TCP keepalive is notoriously difficult to maintain, with many edge cases to handle and debug. For a great example of these challenges, you can read this <a class=link href=https://blog.cloudflare.com/when-tcp-sockets-refuse-to-die/ target=_blank rel=noopener>insightful post from Cloudflare</a>.</p><h2 id=the-problem>The Problem</h2><p>The standard gRPC keepalive mechanism relies on HTTP/2 ping frames to maintain connection health. However, when using Nginx as a proxy, these ping frames don&rsquo;t work as expected. Nginx acknowledges (ACKs) these ping frames instead of forwarding them, effectively breaking the keepalive mechanism. This creates a situation where:</p><ol><li>The client sends HTTP/2 ping frames</li><li>Nginx receives and acknowledges these pings</li><li>The actual gRPC server never sees these pings</li><li>The connection health check fails</li></ol><p>Since the gRPC keepalive can be enabled on the server side as well, it creates an opposite situation:</p><ol><li>The client connection is lost</li><li>The server sends keepalive pings to the (supposedly) client</li><li>Nginx acknowledges these pings</li><li>The server thinks the connection is still alive and keeps it open</li></ol><h2 id=the-failed-partial-workaround>The Failed Partial Workaround</h2><p>To be completely honest, my first thought was to get rid of Nginx. But I can&rsquo;t just remove the reverse proxy. Maybe some other proxy would behave differently and forward PING frames?</p><p>But nope, I tried Envoy proxy and it behaves the same way: it just ACKs the PING frames.</p><h3 id=the-server-side-ping-attempt>The Server-Side Ping Attempt</h3><p>As a reminder, my stream is unidirectional - the server notifies the client about some messages, but the client can&rsquo;t send any data (apart from the first request to establish the connection). So I had this great idea: The server should send frequent gRPC messages that act as a ping, and if it fails to send many of those messages, then I should be able to detect it and terminate the connection. That sounds easy.</p><p>But, after trying it&mldr; another dead end. Even with the client on airplane mode, my server was happily sending gRPC messages to the stream, and nothing happened - the client obviously didn&rsquo;t receive any message, but the server wouldn&rsquo;t complain. It was almost like someone was queuing those messages in a buffer and sending them when the client is available&mldr;</p><h3 id=the-nginx-buffering-discovery>The Nginx Buffering Discovery</h3><p>That was my theory, and I was correct. It seems that Nginx (as a good citizen) buffers the messages and forwards them when it can (<a class=link href=https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffering target=_blank rel=noopener>documentation</a>). I thought about disabling this buffering, since it is possible to do so, but I discarded that idea - The server has many gRPC endpoints apart from this one, and I don&rsquo;t want to lose the buffering benefits just for this use case. There had to be another way&mldr;</p><h2 id=the-successful-workaround>The Successful Workaround</h2><p>So, this is what finally worked 🎊: a mechanism that relies on the client sending pings, and the server responding to these pings, all using gRPC messages. This approach:</p><ol><li>Uses standard gRPC messages instead of HTTP/2 ping frames</li><li>Can be properly proxied by Nginx</li><li>Maintains (almost) the same functionality as the built-in keepalive mechanism</li></ol><h2 id=implementation-details>Implementation Details</h2><p>I&rsquo;ve created a demonstration repository that shows how to implement this custom keepalive mechanism: <a class=link href=https://github.com/hectorgabucio/nginx-hates-grpc-keepalive target=_blank rel=noopener>nginx-hates-grpc-keepalive</a>.</p><p>This work-around introduced a breaking change in my original stream: I can&rsquo;t just rely on a unidirectional server-stream. I actually need a bidirectional stream, where both client and server can send and receive ping requests.</p><p>This is the proto definition of the contract:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=kd>service</span> <span class=n>StreamService</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=c1>// Bidirectional streaming RPC
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>rpc</span> <span class=n>Stream</span> <span class=p>(</span><span class=n>stream</span> <span class=n>StreamMessage</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>StreamMessage</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>StreamMessage</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=k>oneof</span> <span class=n>content</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>        <span class=n>StreamRequest</span> <span class=n>request</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>        <span class=n>StreamResponse</span> <span class=n>response</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>        <span class=n>Ping</span> <span class=n>ping</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>        <span class=n>Pong</span> <span class=n>pong</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>StreamRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=n>query</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>StreamResponse</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=kd>message</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>int32</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>Ping</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>int64</span> <span class=n>timestamp</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>Pong</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>int64</span> <span class=n>original_timestamp</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>int64</span> <span class=n>server_timestamp</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>Please note the <code>Ping</code> and <code>Pong</code> messages: those are part of our home-made keepalive system.</p><p>The custom ping mechanism works as follows:</p><ol><li><p><strong>Client-side behavior:</strong></p><ul><li>Sends frequent ping messages to the server (StreamMessage with content Ping)</li><li>Expects a ping reply from the server (StreamMessage with content Pong)</li><li>Terminates the connection if no reply is received within a reasonable timeframe</li></ul></li><li><p><strong>Server-side behavior:</strong></p><ul><li>Monitors incoming ping messages from the client (StreamMessage with content Ping) and replies (StreamMessage with content Pong)</li><li>Terminates the connection if no pings are received within the expected interval</li></ul></li></ol><p>This bidirectional ping mechanism ensures both sides can detect connection issues and take appropriate action.</p><p>It is really simple to maintain and it works great - Nginx will forward these messages since they&rsquo;re just gRPC messages. However, there are two important considerations to keep in mind:</p><h3 id=ping-frequency>Ping Frequency</h3><p>Finding the right balance for ping frequency is crucial:</p><ul><li>Too frequent pings: Unnecessary network overhead and server load</li><li>Too infrequent pings: Delayed detection of connection issues</li><li>Recommended: Start with 10-second intervals and adjust based on your needs</li></ul><h3 id=security-considerations>Security Considerations</h3><p>Even with authentication in place, you need to protect against potential abuse:</p><ol><li><p><strong>Rate Limiting</strong></p><ul><li>Implement a rate limiter per connection</li><li>Example: Limit to 10 pings per 10-second window</li><li>Terminate connections that exceed the limit</li><li>This prevents DoS attacks from authenticated clients</li></ul></li><li><p><strong>Why It&rsquo;s Necessary</strong></p><ul><li>Authentication only protects against unauthorized access</li><li>Once authenticated, clients can still send excessive pings</li><li>Without rate limiting, a single client could overwhelm your server</li><li>This is especially important for public-facing services</li></ul></li></ol><h2 id=conclusion>Conclusion</h2><p>This journey through implementing gRPC keepalive with Nginx has taught me several important lessons:</p><ol><li><p><strong>HTTP/2 Pings Don&rsquo;t Work with Proxies</strong></p><ul><li>Nginx and Envoy both ACK HTTP/2 ping frames instead of forwarding them</li><li>This breaks the standard gRPC keepalive mechanism</li><li>The issue is well-documented but marked as &ldquo;WONT FIX&rdquo; by the Nginx team</li></ul></li><li><p><strong>Server-Side Pings Aren&rsquo;t Reliable</strong></p><ul><li>Nginx&rsquo;s buffering behavior makes server-side ping detection unreliable</li><li>Messages get queued even when the client is disconnected</li><li>Disabling buffering isn&rsquo;t a viable solution for most setups</li></ul></li><li><p><strong>The Solution: Client-Initiated Pings</strong></p><ul><li>Using regular gRPC messages for keepalive works reliably</li><li>The client sends pings, and the server responds</li><li>Nginx properly forwards these messages</li><li>We get the same functionality as built-in keepalive</li></ul></li><li><p><strong>Important Considerations</strong></p><ul><li>Need to implement proper rate limiting</li><li>Must balance ping frequency</li><li>Should monitor connection health</li><li>Requires bidirectional streams</li></ul></li></ol><p>While not ideal, this workaround provides a reliable solution for maintaining healthy gRPC connections through Nginx proxies. It&rsquo;s a good example of how sometimes we need to think outside the box when working with complex infrastructure setups, especially when dealing with mobile clients that may have unreliable connections.</p><p>For a complete implementation example, check out the <a class=link href=https://github.com/hectorgabucio/nginx-hates-grpc-keepalive target=_blank rel=noopener>nginx-hates-grpc-keepalive</a> repository. Feel free to play with it - enable gRPC pings, try it with the Nginx or Envoy proxy, etc. 🚀</p><h2 id=thoughts>Thoughts</h2><p>While gRPC&rsquo;s built-in keepalive mechanism works perfectly for direct client-server communication, this scenario is rare in production environments. In reality, 99% of deployments use load balancers, proxies, and other infrastructure components.</p><p>The proxy teams&rsquo; decision to respond to HTTP/2 PING frames with ACKs makes perfect sense from their perspective. However, this creates a challenge for gRPC&rsquo;s keepalive mechanism, which relies on these standard HTTP/2 frames.</p><p>I believe gRPC should reconsider its keepalive implementation. Instead of relying on HTTP/2 standard frames, it could use gRPC standard messages for health checks. This would make it much easier to implement reliable connection monitoring in real-world scenarios, especially for:</p><ul><li>Long-lasting stream connections</li><li>Mobile client applications</li><li>Real-time data updates (similar to WebSocket functionality)</li><li>Production environments with complex infrastructure</li></ul><p>In my case, this would have simplified the implementation of real-time notifications for mobile clients about relevant data changes. The current workaround works, but a native solution would be more elegant and maintainable.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/grpc/>Grpc</a>
<a href=/tags/go/>Go</a>
<a href=/tags/nginx/>Nginx</a>
<a href=/tags/networking/>Networking</a>
<a href=/tags/backend/>Backend</a>
<a href=/tags/http2/>Http2</a>
<a href=/tags/keepalive/>Keepalive</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2025 Héctor's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>